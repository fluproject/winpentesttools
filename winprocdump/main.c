#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <psapi.h>
#include <time.h>
#include <malloc.h>
//Step 1 > Add to: Project->Build options->Linked settings "-lpsapi"
//Step 2 > Build & run!

VOID DumpBuffer(const unsigned char* pBuffer, size_t sz, char* filename, int format)
{
    size_t i;
    FILE *fp;
    fp=fopen(filename, "a");
    for (i = 0; i < sz; ++i)
    {
        switch(format)
        {
            case 1:
                fprintf(fp, "0x%x", pBuffer[i]);
                break;
            case 2:
                fprintf(fp, "%c", pBuffer[i]);
                break;
            default:
                break;
        }
    }
    fclose(fp);
}
BOOL DumpProcessMemory(DWORD dwPid, int format)
{
    HANDLE pHandle;
    SYSTEM_INFO si;
    MEMORY_BASIC_INFORMATION mbi;
    LPVOID lpMem;
    DWORD dwReturn, dwTotalRead;
    pHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, dwPid);

    time_t t = time(NULL);
    char filename[30];
    struct tm tm = *localtime(&t);
    sprintf(filename, "%d%d%d-%d%d%d.dmp", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
    if (pHandle == NULL)
    {
        printf("OpenProcess failed for PID: %d\n",dwPid);
        return FALSE;
    }
    GetSystemInfo(&si);
    lpMem = si.lpMinimumApplicationAddress;
    while (lpMem < si.lpMaximumApplicationAddress)
    {
        mbi.RegionSize = 0;
        dwReturn = VirtualQueryEx(pHandle, lpMem, &mbi, sizeof(mbi));
        if (dwReturn == sizeof(mbi)) {
            if ((mbi.Type == MEM_PRIVATE) && (mbi.State == MEM_COMMIT))
            {
                if (mbi.RegionSize > 0)
                {
                    const BYTE* cbBuffer = (BYTE*)HeapAlloc(GetProcessHeap(), NULL, mbi.RegionSize);
                    if (cbBuffer == NULL)
                    {
                        printf ("HeapAlloc failed\n");
                        return FALSE;
                    }
                    ReadProcessMemory(pHandle, mbi.BaseAddress, (LPVOID)cbBuffer, mbi.RegionSize, &dwTotalRead);
                    DumpBuffer(cbBuffer, mbi.RegionSize, filename, format);
                    HeapFree(GetProcessHeap(), NULL, (LPVOID)cbBuffer);
                }
            }
            lpMem = (LPVOID)((DWORD)mbi.BaseAddress + mbi.RegionSize);
        }
        else break;
    }
    CloseHandle(pHandle);
    _tprintf("The memory dump has been copied in this path: %s", filename);
    return TRUE;
}
DWORD PrintModules( DWORD processID )
{
    HMODULE hMods[1024];
    HANDLE hProcess;
    DWORD cbNeeded;
    unsigned int i;
    // Print the process identifier.
    printf( " - Modules:\n" );
    // Get a handle to the process.
    hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID );
    if (NULL == hProcess)
        return 1;
    // Get a list of all the modules in this process.
    if( EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))
    {
        for ( i = 0; i < (cbNeeded / sizeof(HMODULE)); i++ )
        {
            TCHAR szModName[MAX_PATH];
            // Get the full path to the module's file.
            if ( GetModuleFileNameEx( hProcess, hMods[i], szModName,  sizeof(szModName) / sizeof(TCHAR)))
            {
                // Print the module name and handle value.
                _tprintf( TEXT("\t* %s (0x%08X)\n"), szModName, hMods[i] );
            }
        }
    }
    // Release the handle to the process.
    CloseHandle( hProcess );
    return hMods[0];
}
void InfoProcess(DWORD processID)
{
    const int bufferSize = 16;
    DWORD buffer[bufferSize];
    HMODULE hMod;
    DWORD cbNeeded;
    SIZE_T bytesRead;
    PROCESS_MEMORY_COUNTERS pmc;
    TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");
    HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID );
    if (hProcess != NULL)
    {
        if ( GetProcessMemoryInfo( hProcess, &pmc, sizeof(pmc)) )
        {
            if ( EnumProcessModules( hProcess, &hMod, sizeof(hMod), &cbNeeded) )
            {
                GetModuleBaseName( hProcess, hMod, szProcessName, sizeof(szProcessName)/sizeof(TCHAR));
            }

            _tprintf(" \nProcess <%d> info:\n\n",processID);
            printf( " - Process name: %s\n", szProcessName);
            _tprintf(" - Address of this process: 0x%08X\n", hMod);
            printf( " - Page Fault Count: 0x%08X\n", pmc.PageFaultCount );
            printf( " - Peak Working Set Size: 0x%08X\n", pmc.PeakWorkingSetSize );
            printf( " - Working Set Size: 0x%08X\n", pmc.WorkingSetSize );
            printf( " - Quota Peak Paged Pool Usage: 0x%08X\n", pmc.QuotaPeakPagedPoolUsage );
            printf( " - Quota Paged Pool Usage: 0x%08X\n", pmc.QuotaPagedPoolUsage );
            printf( " - Quota Peak Non Paged Pool Usage: 0x%08X\n", pmc.QuotaPeakNonPagedPoolUsage );
            printf( " - Quota Non Paged Pool Usage: 0x%08X\n", pmc.QuotaNonPagedPoolUsage );
            printf( " - Page file Usage: 0x%08X\n", pmc.PagefileUsage );
            printf( " - Peak Page file Usage: 0x%08X\n", pmc.PeakPagefileUsage );
            PrintModules(processID);
        }
        CloseHandle(hProcess);
    }
    else
        _tprintf("Could not open process for memory reading.\n");
}

void AnalyzeProcess(DWORD processID)
{
    TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");
    // Get a handle to the process.
    HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID );
    // Get the process name.
    if (NULL != hProcess )
    {
        HMODULE hMod;
        DWORD cbNeeded;
        if ( EnumProcessModules( hProcess, &hMod, sizeof(hMod), &cbNeeded) )
        {
            GetModuleBaseName( hProcess, hMod, szProcessName, sizeof(szProcessName)/sizeof(TCHAR));
        }
    }
    // Print the process name and identifier.
    _tprintf( TEXT("\n - PID: %u (%s)"), processID, szProcessName);
    // Release the handle to the process.
    CloseHandle( hProcess );
}
int main( void )
{
    _tprintf("\n
#    # # #    # #####  #####   ####   ####  #####  #    # #    # #####
#    # # ##   # #    # #    # #    # #    # #    # #    # ##  ## #    #
#    # # # #  # #    # #    # #    # #      #    # #    # # ## # #    #
# ## # # #  # # #####  #####  #    # #      #    # #    # #    # #####
##  ## # #   ## #      #   #  #    # #    # #    # #    # #    # #
#    # # #    # #      #    #  ####   ####  #####   ####  #    # #
             \n");
    _tprintf("\n#####################################################################\n");
    _tprintf("\n## Designed by Juan Antonio Calles (@jantonioCalles & @fluproject) ##\n");
    _tprintf("\n#####################################################################\n");

    DWORD aProcesses[1024], cbNeeded, cProcesses;
    unsigned int i, format=0;
    int process, option;

    while(1)
    {
        _tprintf("\n\nSelect an option:");
        _tprintf("\n 1.- List all processes");
        _tprintf("\n 2.- Get info of a process");
        _tprintf("\n 3.- Dump a process");
        _tprintf("\n 4.- Exit");
        _tprintf("\n\nOption: ");
        scanf("%d",&option);
        switch(option)
        {
            case 1:
                // Get the list of process identifiers.
                if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))
                    return 1;
                // Calculate how many process identifiers were returned.
                cProcesses = cbNeeded / sizeof(DWORD);
                // Print the name and process identifier for each process.
                _tprintf(" \nYour processes:\n\n");
                for ( i = 0; i < cProcesses; i++ )
                {
                    if( aProcesses[i] != 0 )
                    {
                        AnalyzeProcess(aProcesses[i]);
                    }
                }
                break;
            case 2:
                _tprintf(" \nSelect a process PID to get information:  ");
                scanf("%d",&process);
                InfoProcess(process);
                break;
            case 3:
                _tprintf(" \nSelect a process PID to dump:  ");
                scanf("%d",&process);
                while((format<1||format>2))
                {
                    _tprintf(" \nSelect a format:  ");
                    _tprintf("\n 1.- Hex");
                    _tprintf("\n 2.- Raw");
                    _tprintf("\n\nOption: ");
                    scanf("%d",&format);
                }
                _tprintf(" \nThe process <%d> is being dumped right now. Please wait, this process could take several minutes...\n\n",process);
                DumpProcessMemory(process, format);
            default:
                return 0;
        }
    }
    return 0;
}
